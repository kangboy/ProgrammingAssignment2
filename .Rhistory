makeVector<-function(x=numeric()){
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function()x
setmean<-function(mean)m<<-mean
getmean<-function()m
list(set=set,get=get,setmean=setmean,getmean=getmean)
}
cachemean<-function(x,...){
m<-x$getmean()
if(!is.null(m)){
message("getting cached data")
return(m)
}
data<-x$get()
m<-mean(data,...)
x$setmean(m)
m
}
a<-makeVector(1)
cachemean(a)
a$set(2)
x
where("x")
library("pryr")
where("x")
ls()
serach()
search()
ls.str()
environment(makeVevtor$set)
environment(a)
environment("a")
where("x")
where("mean")
makeVector<-function(x=numeric()){
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
where("x")
}
get<-function()x
setmean<-function(mean)m<<-mean
getmean<-function()m
list(set=set,get=get,setmean=setmean,getmean=getmean)
}
a<-makeVector(1)
cachemean(a)
a$set(w)
a$set(2)
b<-makeVector(3)
b$set(4)
a<-makeVector(1)
a$ste(2)
a$stet(2)
a$set(2)
a$set(3)
parent.frame(a$set(3))
parent.frame("a$set(3)")
?parent.frame
parent.env(a$set(3))
environment("a$set(3)")
ls(0x0000000007539910)
ls("0x0000000007539910")
a$set(3)
x<-2
where("x")
mat<-matrix(1:9,3,3)
solve(mat)
?solve
mat<-matrix(rnorm(9),3,3)
mat
solve(mat)
solve(mat)%*%mat
## A pair of functions to compute and cache the inverse of a matrix.
## Cache the inverse by returning a special "matrix" which is actually a list
## containing four functions.
makeCacheMatrix <- function(x = matrix()) {
inverse<-NULL
set<-function(y){
x<<-y
inverse<<-NULL
}
get<-function()x
setinverse<-function(inv)inverse<<-inv
getinverse<-function()inverse
list(set=set,get=get,setinverse=setinverse,getinverse=getinverse)
}
## Calculates the inverse of a matrix. However, it first checks to see if
## the inverse has already been calculated. If so, it gets the inverse
## from the cache and skips the calculation. If not, it computes the inverse
## and cache it.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv<-x$getinverse()
if(!is.null(inv)){
message("getting cached data!")
return(inv)
}
data<-x$get()
inv<-solve(data,...)
x$setinverse(inv)
inv
}
a<-makeCacheMatrix(rnorm(16),4,4)
mat<-matrix(rnorm(100),10,10)
a<-makeCacheMatrix(mat)
cacheSlove(a)
cacheSolve(a)
cacheSolve(a)
## A pair of functions to compute and cache the inverse of a matrix.
## Cache the inverse by returning a special "matrix" which is actually a list
## containing four functions.
makeCacheMatrix <- function(x = matrix()) {
inverse<-NULL
set<-function(y){
x<<-y
inverse<<-NULL
}
get<-function()x
setinverse<-function(inv)inverse<<-inv
getinverse<-function()inverse
list(set=set,get=get,setinverse=setinverse,getinverse=getinverse)
}
## Calculates the inverse of a matrix. However, it first checks to see if
## the inverse has already been calculated. If so, it gets the inverse
## from the cache and skips the calculation. If not, it computes the inverse
## and cache it.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv<-x$getinverse()
if(!is.null(inv)){
message("getting cached data!")
return(inv)
}
data<-x$get()
inv<-solve(data,...)
x$setinverse(inv)
inv
}
mat<-matrix(norm(100),10,10)
mat<-matrix(rnorm(100),10,10)
makeCacheMatrix(mat)
cacheSolve(a)
cacheSolve(makeCacheMatrix(mat))
cacheSolve(makeCacheMatrix(mat))
cacheSolve(makeCacheMatrix(mat))
a<-makeCacheMatrix(mat)
cacheSolve(a)
cacheSolve(a)
